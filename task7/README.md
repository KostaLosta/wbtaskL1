## Конкурентная запись в map в Go

Этот пример демонстрирует безопасную (без гонок) запись в структуру `map` при конкурентном доступе с помощью `sync.Mutex`. Также показано, как проверить программу на наличие гонок с флагом `-race`.

### Почему возникает проблема

- **Гонки данных (data race)**: ситуация, когда две и более горутины одновременно обращаются к одной и той же области памяти, и хотя бы одна из них — с записью, при этом доступ не синхронизирован. Это приводит к неопределённому поведению.
- В Go встроенный `map` не потокобезопасен. Любые конкурентные записи/чтения без синхронизации приводят к гонкам.

### Способ сделать доступ к map безопасным

- **`sync.Mutex`**: оборачиваем `map` в структуру с мьютексом и блокируем доступ на время операций чтения/записи.

### Что реализовано в этом примере

- Обёртка `SafeMap` над встроенной `map[int]int` с использованием `sync.Mutex` и методами `Set`, `Get`, `Len`.
- Нагрузочный тест: несколько горутин параллельно выполняют большое количество записей в разные ключи.

### Как проверить на гонки данных
Для проверки программы на наличие гонок данных используйте флаг `-race`:

```bash
# Запуск с проверкой на гонки
go run -race main.go
```

**Важно**: программа с флагом `-race` работает медленнее, поэтому используйте его только для тестирования, а не в продакшене.

Если гонок нет, программа выполнится без сообщений об ошибках. При обнаружении гонок Go выведет подробную информацию о проблемных местах.

### Частые ошибки и рекомендации

- Не выполняйте никаких операций с `map` из нескольких горутин без синхронизации — это почти гарантированная гонка.
- Старайтесь минимизировать зону блокировки (держать `Lock` только на время критически необходимого участка).
- Не забывайте про копирование ссылочных типов: если `map` хранит указатели/срезы/карты, синхронизация доступа к самим значениям тоже важна.
- Не используйте `defer Unlock()` в сверхгорячих путях, если критично каждое наносекундное задерживание — в остальных случаях `defer` повышает безопасность кода.


